import { register } from 'ags/gobject';
import { Astal, Gdk, Gtk } from 'ags/gtk4';
import app from 'ags/gtk4/app';
import { createPoll, idle, timeout } from 'ags/time';
import AstalAuth from 'gi://AstalAuth';
import Gtk4SessionLock from 'gi://Gtk4SessionLock';

import { get_hyprland_monitor_desc } from '../../lib';
import { setCss } from '../../lib/widgets';
import Separator from '../misc/separator';
// This file is generated by Nix
import Vars from './vars';

declare global {
    function authFinger(): void;
}

@register()
class BlurredBox extends Astal.Box {
    geometry = {} as { w: number; h: number };
}

export default () => {
    const windows = new Map<Gdk.Monitor, Gtk.Window>();
    const blurBGs: BlurredBox[] = [];

    const transition_duration = 1000;
    const WINDOW_MARGINS = -2;
    const ENTRY_SPACING = 20;
    const CLOCK_SPACING = 60;

    const bgCSS = ({ w = 1, h = 1 } = {}) => `* {
        border: 2px solid rgba(189, 147, 249, 0.8);
        background: rgba(0, 0, 0, 0.2);
        min-height: ${h}px;
        min-width: ${w}px;
        transition: min-height ${transition_duration / 2}ms,
                    min-width ${transition_duration / 2}ms;
    }`;

    const lock = Gtk4SessionLock.Instance.new();

    const unlock = () => {
        blurBGs.forEach((b) => {
            setCss(
                b,
                bgCSS({
                    w: b.geometry.w,
                }),
            );

            timeout(transition_duration / 2, () => {
                setCss(
                    b,
                    bgCSS({
                        w: 0,
                        h: 0,
                    }),
                );
            });
        });
        timeout(transition_duration + 100, () => {
            lock.unlock();
            Gdk.Display.get_default()?.sync();
            app.quit();
        });
    };

    const Clock = () => {
        const time = createPoll('', 1000, () => {
            return (
                new Date().toLocaleString([], {
                    hour: 'numeric',
                    minute: 'numeric',
                    hour12: true,
                }) ?? ''
            )
                .replace('a.m.', 'AM')
                .replace('p.m.', 'PM');
        });

        return <label cssClasses={['lock-clock']} label={time} />;
    };

    const PasswordPrompt = (monitor: Gdk.Monitor, visible: boolean) => {
        const rev = (<BlurredBox css={bgCSS()} />) as BlurredBox;

        idle(() => {
            rev.geometry = {
                w: monitor.get_geometry().width,
                h: monitor.get_geometry().height,
            };

            setCss(
                rev,
                bgCSS({
                    w: rev.geometry.w,
                }),
            );

            timeout(transition_duration / 2, () => {
                setCss(
                    rev,
                    bgCSS({
                        w: rev.geometry.w,
                        h: rev.geometry.h,
                    }),
                );
            });
        });

        blurBGs.push(rev);

        <window
            name={`blur-bg-${monitor.get_model()}`}
            namespace={`blur-bg-${monitor.get_model()}`}
            gdkmonitor={monitor}
            layer={Astal.Layer.OVERLAY}
            visible
            anchor={
                Astal.WindowAnchor.TOP |
                Astal.WindowAnchor.LEFT |
                Astal.WindowAnchor.RIGHT |
                Astal.WindowAnchor.BOTTOM
            }
            margin={WINDOW_MARGINS}
            exclusivity={Astal.Exclusivity.IGNORE}
        >
            <box halign={Gtk.Align.CENTER} valign={Gtk.Align.CENTER}>
                {rev}
            </box>
        </window>;

        const label = (<label label="Enter password:" />) as Gtk.Label;

        return new Gtk.Window({
            child: visible
                ? ((
                      <box
                          orientation={Gtk.Orientation.VERTICAL}
                          halign={Gtk.Align.CENTER}
                          valign={Gtk.Align.CENTER}
                          spacing={16}
                      >
                          <Clock />

                          <Separator size={CLOCK_SPACING} vertical />

                          <box
                              halign={Gtk.Align.CENTER}
                              cssClasses={['avatar']}
                          />

                          <box
                              cssClasses={['entry-box']}
                              orientation={Gtk.Orientation.VERTICAL}
                          >
                              {label}

                              <Separator size={ENTRY_SPACING} vertical />

                              <entry
                                  halign={Gtk.Align.CENTER}
                                  xalign={0.5}
                                  visibility={false}
                                  placeholder_text="password"
                                  onRealize={(self) => self.grab_focus()}
                                  onActivate={(self) => {
                                      self.set_sensitive(false);

                                      AstalAuth.Pam.authenticate(
                                          self.get_text() ?? '',
                                          (_, task) => {
                                              try {
                                                  AstalAuth.Pam.authenticate_finish(
                                                      task,
                                                  );
                                                  unlock();
                                              }
                                            catch (e) {
                                                  self.set_text('');
                                                  label.set_label(
                                                      (e as Error).message,
                                                  );
                                                  self.set_sensitive(true);
                                              }
                                          },
                                      );
                                  }}
                              />
                          </box>
                      </box>
                  ) as Astal.Box)
                : ((<box />) as Astal.Box),
        });
    };

    const createWindow = (monitor: Gdk.Monitor) => {
        const hyprDesc = get_hyprland_monitor_desc(monitor);
        const entryVisible =
            Vars.mainMonitor === hyprDesc || Vars.dupeLockscreen;
        const win = PasswordPrompt(monitor, entryVisible);

        windows.set(monitor, win);
    };

    const lock_screen = () => {
        const display = Gdk.Display.get_default();

        for (let m = 0; m < (display?.get_monitors().get_n_items() ?? 0); m++) {
            const monitor = display?.get_monitors().get_item(m) as Gdk.Monitor;

            if (monitor) {
                createWindow(monitor);
            }
        }

        display?.get_monitors()?.connect('items-changed', () => {
            for (
                let m = 0;
                m < (display?.get_monitors().get_n_items() ?? 0);
                m++
            ) {
                const monitor = display
                    ?.get_monitors()
                    .get_item(m) as Gdk.Monitor;

                if (monitor && !windows.has(monitor)) {
                    createWindow(monitor);
                }
            }
        });

        lock.lock();

        windows.forEach((win, monitor) => {
            lock.assign_window_to_monitor(win, monitor);
            win.show();
        });
    };

    if (Vars.hasFprintd) {
        globalThis.authFinger = () =>
            AstalAuth.Pam.authenticate('', (_, task) => {
                try {
                    AstalAuth.Pam.authenticate_finish(task);
                    unlock();
                }
                catch (e) {
                    console.error((e as Error).message);
                }
            });
        globalThis.authFinger();
    }
    lock_screen();
};
